```{r}
# Load required libraries
library(sf)
library(mapview)
library(ggplot2)
library(ggspatial)
library(dplyr)

# Read data
parking<-read.csv("Parking.csv")
business<-read.csv("business.csv")

# Convert the business dataset to a spatial object
business_sf <- st_as_sf(business, coords = c("long", "lat"), crs = 4326)

# Convert the parking dataset to a spatial object
parking_sf <- st_as_sf(parking, coords = c("lng", "lat"), crs = 4326)

# Perform a spatial join to find the nearest business for each parking space
nearest_business <- st_nearest_feature(parking_sf, business_sf)

# Add the nearest business information to the parking dataset
parking_data_with_nearest_business <- cbind(parking, nearest_business)

#Display data on map
map<-parking_data_with_nearest_business %>%
  st_as_sf(
    coords=c("lng","lat"),
    crs=4326
  )

map %>% mapview()

```


```{r}
# (To be replaced with traffic volume data)
parking_data_with_nearest_business$traffic_volume = c(100, 150, 90, 50, 250, 75, 65, 40)

```

```{r}
# An empty list to store the results
result_list <- list()

# Iterate through each parking spot and business data
for (i in 1:nrow(parking_data_with_nearest_business)){
  
  # A temporary data frame to store the results for this parking spot
  temp_df <- data.frame(
    address = character(),
    lat = double(),
    lng = double(),
    distance = double(),
    capacity = integer(),
    traffic_volume = integer(),
    n_business = integer(),
    n_customers =integer(),
    time_spent = double(),
    category = character(),
    
    stringsAsFactors = FALSE
  )
  
  for( j in 1:nrow(business)){
    lon1 <- parking_data_with_nearest_business[i,"lng"]
    lat1 <- parking_data_with_nearest_business[i,"lat"]
    lon2 <- business[j, "long"]
    lat2 <- business[j, "lat"]
    
    # Function to calculate angular distance between two points on Earth
    haversine_distance <- function(lon1, lat1, lon2, lat2) {
      R <- 6371 # Earth radius in km
      dlat <- (lat2 - lat1) * pi / 180
      dlon <- (lon2 - lon1) * pi / 180
      a <- sin(dlat/2)^2 + cos(lat1 * pi / 180) * cos(lat2 * pi / 180) * sin(dlon/2)^2
      c <- 2 * atan2(sqrt(a), sqrt(1 - a))
      distance <- R * c
      return(distance) # Distance in km
    }
    
    distance <- haversine_distance(lon1, lat1, lon2, lat2)

    # Store the results in the temporary data frame
    temp_df[nrow(temp_df) + 1, ] <- list(
      address = parking_data_with_nearest_business[i,"address"],
      lat = parking_data_with_nearest_business[i,"lat"],
      lng = parking_data_with_nearest_business[i,"lng"],
      distance = distance,
      capacity = parking_data_with_nearest_business[i,"capacity"],
      traffic_volume = parking_data_with_nearest_business[i,"traffic_volume"],
      n_business = parking_data_with_nearest_business[i,"nearest_business"],
      n_customers = business[j,"qCustomer"],
      time_spent = business[j,"tCustomer"],
      category = business[j,"Category"]
    )
  }
  
  # Append the temporary data frame to the result list
  result_list[[i]] <- temp_df
}

# Combine all the results into a single data frame
result_df <- do.call(rbind, result_list)

```
```{r}
# Filter data to have rows that have distance less than 50 meters between parking spot and business
filtered_result_df <- result_df %>%
  filter(distance <= 0.05)

```


```{r}

# Define a scoring function
calculate_score <- function(traffic_volume, capacity, nearest_businesses, customers, c_time, distance) {
  
  # Define weights for each factor
  weights <- c(0.2, 0.2, 0.2, 0.2, 0.2, 0.1)
  
  # Normalize each factor
  normalized_traffic <- (traffic_volume - min(traffic_volume)) / (max(traffic_volume) - min(traffic_volume))
  normalized_capacity <- (capacity - min(capacity)) / (max(capacity) - min(capacity))
  normalized_n_businesses <- (nearest_businesses - min(nearest_businesses)) / (max(nearest_businesses) - min(nearest_businesses))
  normalized_customers <-(customers - min(customers)) / (max(customers) - min(customers))
  normalized_distance <- (distance - min(distance)) / (max(distance) - min(distance))
  normalized_time <- (c_time - min(c_time)) / (max(c_time) - min(c_time))
  
  # Calculate the score
  score <- weights[1] * normalized_traffic +
    weights[2] * normalized_capacity +
    weights[3] * normalized_distance +
    weights[4] * normalized_n_businesses + 
    weights[5] *(normalized_customers * normalized_time)
  
  return(abs(score))
}


# Calculate score for each parking spot
filtered_result_df$score <- calculate_score(filtered_result_df$traffic_volume, filtered_result_df$capacity, filtered_result_df$n_busines, filtered_result_df$n_customers, filtered_result_df$time_spent,filtered_result_df$distance)

# Rank the parking spots based on the score
ranked_data <- filtered_result_df[order(-filtered_result_df$score),]

# Print the ranked data
print(ranked_data)
```
```{r}
# Find highest scored parking spot
highest_score_index <- which.max(ranked_data$score)
highest_score_parking_spot <- filtered_result_df[highest_score_index, ]

# Print the result
print(paste0("Address of parking spot: ",highest_score_parking_spot$address))
print(paste0("Latitude of parking spot: ",highest_score_parking_spot$lat))
print(paste0("Longitude of parking spot: ",highest_score_parking_spot$lng))


```
